# Everything here is reverse from the .exe version 5.16.0
# Clean versions of functions are proposed where the assembly was not optimized
# (of course it's ASM translated in C++ then translated in Python)
# by ThiSpawn on 25/12/2016, fuck christmas
import numpy as np

from wows_shell import *
from mackbot.utilities.math import lerp
from mackbot.utilities.logger import logger

data = {"_id":{"$oid":"647b7b349e60264088778875"},"profile":{"artillery":{"shotDelay":30,"caliber":0.46,"numBarrels":3,"burn_probability":35,"sigma":2.1,"range":26630,"dispersion_h":{"5000":50,"10000":156,"15000":192,"20000":228,"25000":264,"26630":276},"dispersion_v":{"5000":40,"10000":125,"15000":154,"20000":182,"25000":211,"26630":221},"transverse_speed":3,"pen":{"he":77,"ap":0,"cs":0},"max_damage":{"he":7300,"ap":14800,"cs":0},"gun_dpm":{"he":131400,"ap":266400,"cs":0},"speed":{"he":805,"ap":780,"cs":0},"krupp":{"he":240,"ap":2574,"cs":0},"mass":{"he":1360,"ap":1460,"cs":0},"drag":{"he":0.543,"ap":0.292,"cs":0},"ammo_name":{"he":"460 mm HE Type0","ap":"460 mm AP/APC Type91","cs":""},"normalization":{"he":8,"ap":6,"cs":0},"fuse_time":{"he":0.001,"ap":0.033,"cs":0},"fuse_time_threshold":{"he":2,"ap":77,"cs":0},"ricochet":{"he":91,"ap":45,"cs":0},"ricochet_always":{"he":60,"ap":60,"cs":0},"turrets":{"460 mm/45 Type 94 in a triple turret":{"numBarrels":3,"count":3,"armor":{"65568":250,"65569":270,"65571":190,"65635":135,"65636":650}}},"taperDist":5000,"idealRadius":10,"idealDistance":1000,"minRadius":2.8,"radiusOnMax":0.8}},"name":"460 mm/45 Type 94 in a triple turret","image":"https://glossary-wows-global.gcdn.co/icons/module/icon_module_Artillery_dea4595bc2cd93d9ce334c9b5a8d3d0738bd57088de2a5ac144aba65e5113e02.png","tag":"PJUA911_B10_ART_STOCK","module_id_str":"PJUA911","module_id":{"$numberLong":"3339693776"},"type":"Artillery","price_credit":2300000,"hash":"90a779a7a0bb48a6da1dac0cd182fe4e5665e65697e9b46b1006a0bdfe28a6cf"}

def build_trajectory(data: dict, ammo_type:str, gun_range:int=-1):
    """
    build shell trajectory
    Args:
        data (dict): artillery module data
        ammo_type (str): ammo type
        gun_range (int): desired range in meters, use -1 for gun's max range.

    Returns:
        s: shell
    """
    if 'profile' not in data:
        if 'artillery' not in data['profile']:
            return None
        return None
    if ammo_type.lower() not in ['ap', 'he', 'cs', 'sap']:
        return None
    if ammo_type.lower() == 'sap':
        ammo_type = 'cs'

    gun_data = data['profile']['artillery']

    s = shell(shellParams(
        gun_data['caliber'],
        float(gun_data['speed'][ammo_type]),
        float(gun_data['drag'][ammo_type]),
        float(gun_data['mass'][ammo_type]),
        float(gun_data['krupp'][ammo_type]),
        float(gun_data['normalization'][ammo_type]),
        float(gun_data['fuse_time'][ammo_type]),
        float(gun_data['fuse_time_threshold'][ammo_type]),
        float(gun_data['ricochet'][ammo_type]),
        float(gun_data['ricochet_always'][ammo_type]),
        ammo_type != 'ap'
    ), "ap")
    c = shellCalc()
    c.setDtMin(.01)
    c.setMax(90)
    c.calcImpactForwardEuler(s, addTraj=True)

    # impact_data = s.getImpact()
    # traj = s.getTrajectory(int(gun_data['range'] / 100) if gun_range == -1 else gun_range)

    return s

def get_trajectory_at_range(s: shell, r: float):
    """
    get trajectory at specified range
    Args:
        s (wows_shell.shell):
        r (float): range

    Returns:
        tuple: trajectory data
    """
    traj_dist, traj_height, _ = None, None, None
    for i in range((int(r) // 100) + 1):
        traj_dist, traj_height, _ = s.getTrajectory(i)
        if traj_dist[-1] >= r:
            return traj_dist, traj_height, _
    return traj_dist, traj_height, _

def get_angle_at_range(impact_data: np.array, value: int):
    """
    Get the gun angle of which where we can fire at range value
    Args:
        impact_data (np.array): numpy array that is generated by build_trajectory
        value (float): desired gun range in meters
    Returns:
        float - gun angle * 10
    """
    for i, dist in enumerate(impact_data[distance]):
        if dist >= value:
            return int(float((i - 1) / 10))

def get_impact_time_at_range(impact_data: np.array, r: int):
    """
    Get time for shell to land at this distance
    Args:
        impact_data (np.array): numpy array that is generated by build_trajectory
        r (int): time taken for shell to land at this range

    Returns:
        float: time in seconds
    """
    angle = int(get_angle_at_range(impact_data, r)) * 10
    try:
        return impact_data[timeToTargetAdjusted][angle]
    except IndexError:
        raise IndexError(f"{angle} is outside of range [0, 90]")

def get_angle_at_max_range(impact_data:np.array, gun_data: dict) -> float:
    """
    Get the gun angle of which where we can fire at max range
    Args:
        impact_data (np.array): numpy array that is generated by build_trajectory
        gun_data (dict): gun data that includes the sub key 'profile['artillery']'

    Returns:
        float - gun angle
    """
    gun_max_range = gun_data['profile']['artillery']['range']
    for i, dist in enumerate(impact_data[distance]):
        if dist > gun_max_range:
            return float((i - 1) / 10)

def get_impact_time_at_max_range(impact_data:np.array, gun_data: dict) -> float:
    """
    Get the time to reach max range
    Args:
        impact_data (np.array): numpy array that is generated by build_trajectory
        gun_data: main battery data

    Returns:
        float: time in seconds
    """
    angle = int(get_angle_at_max_range(impact_data, gun_data) * 10)
    try:
        return impact_data[timeToTargetAdjusted][angle]
    except IndexError:
        raise IndexError(f"{angle} is outside of range [0, 90]")

def get_penetration_at_range(impact_data: np.array, a: int, range_factor: float):
    """
    get approximate penetration value at certain range
    Args:
        impact_data (dict): data generated by build_trajectory.getImpact()
        a (int): angle
        range_factor (float): penetration multiplicitive inverse factor at range (I suspect penetration increases from 2 -> 3 as it approaches max range)

    Returns:

    """
    h_pen, v_pen = impact_data[effectivePenetrationHorizontalNormalized][a], impact_data[effectivePenetrationDeckNormalized][a]

    logger.info(f"pen at {a} degree {h_pen:0.0f}mm x {v_pen:0.0f}mm")
    return np.sqrt((h_pen * h_pen) + (v_pen * v_pen)) / (2 + range_factor)

def calc_dispersion(gun_module: dict, gun_range: float):
    """
    calculate dispersion at any range
    Args:
        gun_module (dict): artillery module data
        gun_range (float): gun range in m

    Returns:
        tuple: (horizontal dispersion, vertical dispersion) in meters
    """
    gun_data = gun_module['profile']['artillery']
    r = min(gun_range, int(gun_module['profile']['artillery']['range']))

    h_disp_at_ideal = gun_data['idealRadius'] * 30  # Horizontal dispersion at idealDistance, in units of 30m
    range_for_ideal = gun_data['idealDistance'] * 30  # Distance at which idealRadius applies, in units of 30m.
    if r > gun_data['taperDist']:
        # minRadius: Horizontal dispersion at zero range, in units of 30m (also used for torp range)
        h_disp = round(lerp(gun_data['minRadius'] * 30, h_disp_at_ideal, r / range_for_ideal))
    else:
        h_disp = round(lerp(0, h_disp_at_ideal, r / range_for_ideal))
    v_disp = round(h_disp * gun_data['radiusOnMax'])  # Ratio of vertical to horizontal dispersion at maximum range

    return h_disp, v_disp

def total_distance_traveled(traj: np.array):
    """
    Find total distance traveled by a salvo
    Args:
        traj (np.array): data generated by build_trajectory

    Returns:
        float
    """
    dist, height, _ = traj
    d = 0
    for index, (x, y) in enumerate(zip(dist, height)):
        if index == 0:
            pass
        d += np.sqrt(((x - dist[index - 1]) ** 2) + ((y - height[index - 1]) ** 2))
    return d / 1000

def within_dispersion(point: tuple, dispersion: tuple):
    """
    return if point within eclipse
    Args:
        point (tuple): point (x, y)
        dispersion (tuple): eclipse with dimension (w, h)

    Returns:
        Boolean
    """
    assert len(point) == 2
    assert len(dispersion) == 2

    x, y = point
    disp_w, disp_h = dispersion

    p = ((x ** 2) / (disp_w ** 2)) + ((y ** 2) / (disp_h ** 2))
    return p <= 1